# Cert-Manager with cloudflare domain validation

This will create a cert-manager issuer that uses cloudflare for domain validation.  This is useful for getting SSL certificates for your services.

## Prerequisites

- A Kubernetes cluster OBVIOUSLY
- Cloudflare account API key or token
  
## Setup Instructions

- RTFM: 
  - https://itnext.io/cilium-gateway-api-cert-manager-and-lets-encrypt-updates-cc730818cb17
  - https://cert-manager.io/docs/installation/kubectl/
  - https://cert-manager.io/docs/configuration/acme/dns01/cloudflare/
- Install the cert-manager release manifest
  ```sh
  helm repo add jetstack https://charts.jetstack.io
  helm repo update

  kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.15.0/cert-manager.crds.yaml

  helm install cert-manager jetstack/cert-manager --version v1.15.0 \
    --namespace cert-manager --create-namespace \
    --set "extraArgs={--enable-gateway-api}"
  ```
- Check on the cert-manager pods
  ```sh
  kubectl get pods --namespace cert-manager
  ```
- Create an API token in Cloudflare
- https://dash.cloudflare.com/profile/api-tokens
  ```sh
  This API token will affect the below accounts and zones, along with their respective permissions
  
  All zones - Zone:Read, DNS:Edit
  ```
- Save API token in a secret
  ```sh
  kubectl create secret generic cloudflare-api-token-secret --from-literal=api-token='xxxxxx'
  ```

- create issuer resource
```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer # I changed this from Issuer to ClusterIssuer so it could issues certs across all namespaces
metadata:
  name: cloudflare-issuer
spec:
  acme:
    email: joemama@gmail.com # This is the email that will be used to register with Let's Encrypt
    privateKeySecretRef:
      name: cloudflare-private-key # This is the secret that will store the private key.  auto-generated by cert-manager
    server: https://acme-v02.api.letsencrypt.org/directory
    solvers:
    - dns01:
        cloudflare:
          apiTokenSecretRef:
            name: cloudflare-api-token-secret
            key: api-token
```

- No need to create use the cloudflare key if you are using a token.  The token is more secure and has less permissions than the key.

## UPDATES

I wanted to add a few things that I learned after setting up the cert-manager.

- I wanted to deploy each app in a separate namespace.  I had to change the issuer to a ClusterIssuer so that it could issue certs across all namespaces.
- In order for that to work, I needed the `cloudflare-api-token-secret` to be in every namespace that I wanted to issue certs in. I did not want to have to create the key over and over again so I installed `relector` to copy the secret value to every namespace.
- https://github.com/emberstack/kubernetes-reflector
- To use Reflector you install it the dependencies
```sh
helm repo add emberstack https://emberstack.github.io/helm-charts
helm repo update
helm upgrade --install reflector emberstack/reflector
```

- In the namespace where you original `cloudflare-api-token-secret` is located (In my case, it was in the default namespace) update the secret to have the `reflector` annotations
```yaml
apiVersion: v1
data:
  api-token: Z......no...peeeking....==
kind: Secret
metadata:
  annotations:
    reflector.v1.k8s.emberstack.com/reflection-allowed: "true"
    reflector.v1.k8s.emberstack.com/reflection-allowed-namespaces: ""
  name: cloudflare-api-token-secret
  namespace: default
type: Opaque
```
- Then in each namespace where you want the secret to be copied to, you add a new secret with a bogus secret value.  I'm not sure if the secret needs the same secret key as the original secret, but I did it anyway.
- This will have slightly different annotations than the original secret
```yaml
‚ùØ   kubectl get secret cloudflare-api-token-secret -o yaml -n unifi
apiVersion: v1
data:
  api-token: aGVsbG8NCg==
kind: Secret
metadata:
  annotations:
    reflector.v1.k8s.emberstack.com/reflects: default/cloudflare-api-token-secret
  labels:
    app: unifi
  name: cloudflare-api-token-secret
  namespace: unifi
type: Opaque
```
- As you can see my secret value decodes to `hello`. It's not the same as the original secret value for `cloudflare-api-token-secret` but it doesn't matter.  The reflector will copy the value from the original secret to the new secret in the namespace.
- Trust me, it works bro.